<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>コロンブス日和 - ExpandHelp</title>
    <style type="text/css">
      body {
        background-color:#ffffff;
        font-size:12;
        font-family: "Hiragino Kaku Gothic ProN","メイリオ", "sans-serif";
      }
      a { text-decoration: none; }
      li.bold { font-weight: bold; }
      div.body { width:340pt; }
      div.left { float:left; width:10%; font-weight:bold;}
      div.right { width:50%;}
      h1 { background-color:#4d4; padding:8pt;}
      code { background-color:#eee; }
      pre { background-color:#eee; }
    </style>
    <script type="text/javascript">
    //setTimeout("location.reload()",1000*5);
    </script>

  </head>

  <body>
    <div class='body'>
      <h1>コロンブス日和 - DragZoom</h1>
      
      <h2>大規模データの検索と閲覧</h2>

      世の中には様々な種類の大規模データが存在しますが、
      きちんとした管理者が存在するデータは
      階層的な構造で管理されているのが普通です。
      地名や電話番号やドメイン名などは厳格に階層的に管理されていますし、
      図書館の蔵書は分類番号を使って階層的に管理されています。
      個人的なデータであっても、
      現在のパソコンのファイルシステムでは、
      フォルダを使って階層的に管理しなければなりません。
      
      <p/>
      一方、世界最大のデータベースであるWebは階層的に管理されていませんし、
      手持ちの書籍のような小規模データは
      手間をかけて階層的に管理するほどでもないので、
      適当に管理している人がほとんどだと思われます。
      
      しかし、管理された大規模階層データは数も種類も圧倒的に多いので、
      現在も将来も
      これらを簡単に検索したり閲覧したりする方法が重要であることは間違いないでしょう。
      
      <p/>
      明示的な階層が存在しないリストのようなものでも、
      あたかも階層が存在するかのように扱うことができる場合があります。
      例えば辞書の場合、
      「aで始まる単語」「bで始まる単語」のように分類を行ない、
      その下に「aaで始まる単語」「abで始まる単語」のような階層を考えれば
      階層データと同じように扱うことができます。
      つまり、ソートが可能なあらゆるデータは
      階層的なデータとして扱うこともできるといえるでしょう。
      
      <h2>階層データの閲覧</h2>
      
      Webのようにリンクで自由に結合された構造のデータと比べると、
      階層的に管理された情報は対話的に閲覧/検索するのが比較的簡単です。
      
      図書館で分類にもとづいて本を捜したり
      辞書で単語を捜したりといった作業は日常的なものですし、
      計算機で階層メニューやフォルダ階層などを操作することは
      一般的になっています。
      
      <p/>
      階層的な構造をもつ大規模データを閲覧するために
      様々なインタフェース手法が利用されています。      
      
      計算機の画面に大量データを全部表示することは不可能ですから、
      なんらかの方法でデータの一部だけを表示する工夫が必要です。
      
      対話的に表示部分を変更しながら大規模データを閲覧するために
      以下のような方法が広く使われています。

      <ul>
        <li>少しずつ順番に見る (e.g. スクロール、辞書や書籍をパラパラめくる)</li>
        <li>キーワードなどでフィルタリングして表示量を減らす</li>
        <li>階層的に選択を繰り返してだんだん細部を表示する (e.g. ファインダ、階層メニュー)</li>
        <li>注目点を部分的に拡大する</li>
        <li>直線的なめらかににズーミングする (e.g. GoogleMaps)</li>
      </ul>
      
      フィルタリングにより絞り込んだデータをスクロールして閲覧するなど、
      これらを組み合わせた手法もよく用いられています。

      <h2>ZUI</h2>
      
      階層メニューやファインダのような方法で大規模データを絞りこむ方法は、
      大規模データの一部分の選択を繰り返すことによる
      非線型なズーミングの一種といえます。
      
      これに対し、
      「Perlin Noise」
      で有名なKen Perlinは、
      2次元画面上に表現したデータ全体を
      なめらかに直線的に拡大したり縮小したりすることによって
      大規模データの閲覧をできるようにする
      「Pad」というZUI (Zooming User Interface)システムを1993年に提案し、
      研究者の間でかなり話題になりました。

      Padのような単純な方法を使えば
      拡大/縮小操作と移動操作だけで
      あらゆる大規模な階層データを楽に閲覧できるわけですから、
      CLI, GUIのつぎに来るのがZUIだと期待され、
      様々なシステムや製品プロトタイプが作成されました。
      
      <blockquote>
        <img src="http://Gyazo.com/05207037fe12c32324bf32c9daa58867.png" width=400>
      </blockquote>

      ところが
      結果的にPadやその後継システムは結局流行ることがなく、
      ZUIの試みはほとんど忘れ去られてしまいました。

      流行らなかった理由はいろいろあるのでしょうが、
      二次元画面を自由に拡大縮小して目的の情報を得ることは
      普通のユーザには難しすぎたということが大きな理由のひとつでしょう。

      また当時はマウスホイールは全く普及しておらず、
      ズーミングのための標準的な操作が存在しなかったことも
      関係しているかもしれません。
      
      <p/>
      現在はGoogleMapsなどで
      ズーミング操作はおなじみになっています。
      地図の場合は操作対象が具体的で
      誰にでも比較的わかりやすいため利用されているようですが、
      地図以外への応用は進んでいませんし、
      スクロール操作とズーミング操作が衝突したり
      操作を間違えることはよくあるのは困りものです。
      
      2次元画面のズーミングを利用したインタフェースが
      今後流行する可能性は低そうです。

      <h2>DragZoom</h2>

      Padのような純粋なZUIは残念ながら普及に成功しませんでしたが、
      スマホのような小さな画面で大規模データを閲覧/検索するためには
      ズーミングとフィルタリングが有効なことは間違いありませんから、
      これらを組合せて
      誰でも使える簡単なインタフェースを工夫すれば
      ズーミングインタフェースが日の目を見ることがあると思います。
      
      <p/>
      私は
      スクロールバーを拡張してズーミングやフィルタリングを可能にした
      「LensBar」というシステムを長年提案しているのですが、
      これを簡単にした「DragZoom」というシステムを紹介します。

      <h3>階層データのズーミング</h3>
        
      下図は、
      フィルタリングとズーミング操作によって
      ファイルを検索しようとしているところです。
      
      最初はUnixのファイル構造のうち
      rootに近い部分だけが表示されています。
      灰色の横線は、エントリが隠れていることを示しています。
      
      <blockquote>
        <img src="https://gyazo.com/5efe9490ba2501cb61fac435fefbe91c.png" width=400>
      </blockquote> 
      
      
      <code>libexec</code>をクリックして右にドラッグするか、
      スマホなどの場合は指でタッチしてから右にドラッグすると
      下のようにリストがズーミングされます。
      
      <blockquote>
        <img src="https://gyazo.com/e8c182efc5827b57950e06f4aa29800e.png" width=400>
      </blockquote>
      
      さらに右にドラッグを行うと、
      下のようにすべてのファイルが見えるようになります。
      
      <blockquote>
        <img src="https://gyazo.com/4b7f18c98cc45ddb1d7f076ddd613d65.png" width=400>
      </blockquote>
      
      階層構造の要素を選択して拡大してブラウジングする方法は
      TreeViewや階層メニューなどでもおなじみですが、
      DragZoomでは左右ドラッグで
      なめらかにズーミングのレベルを調整していることになります。
      
      <p/>
      複数の指を利用できるスマホやタブレットでは
      ピンチ操作でもズームレベルを変えることができます。
      
      <h3>ドラッギングによるスクロール</h3>
      
      上下にマウスドラッグを行なうと、
      スマホのスクロール操作と同じように
      画面をスクロールすることができます。
      
      <blockquote>
        <img src="https://gyazo.com/19fb983e24f8c0c820719cccb946a5c0.png" width=400>
      </blockquote>
      
      スクロール操作とズーミング操作は完全に可逆的なので、
      スクロールしたりズーミングしたりした後で
      カーソルをもとの位置まで戻すと
      画面は最初の状態に戻ります。
      
      <h3>フィルタリングとズーミングの組合せ</h3>
      
      テキスト入力枠に「ruby」と入力すると、
      以下のように
      「ruby」を含むファイルやディレクトリだけが表示されます。
      ファイル名の左側にはフォルダ名も縦に表示されているので、
      どのフォルダのファイル名がマッチしたのかがすぐわかります。
      
      <blockquote>
        <img src="https://gyazo.com/daec4f683bcfeacf727af3ace03c353a.png" width=400>
      </blockquote>
      
      この状態では「ruby」を含まないファイル名は全く表示されていませんが、
      「/usr/bin/ruby」の部分をズーミングすると
      以下のように「usr」「include」なども見えるようになります。
      DragZoomでは、
      リストの各エントリに「重要度」を設定しており、
      マウスや指を移動したときはスレシホールドを変化させて
      スレシホールドより大きな重要度を持つ行を表示するようになっています。
      「usr」や「include」のように
      階層のrootに近いファイルには大きな重要度を与えているため、
      キーワードにマッチされていなくても表示されるというわけです。
      
      <blockquote>
        <img src="https://gyazo.com/0aa6324279c4837e6013dac920b8d0d5.png" width=400>
      </blockquote>
      
      <h3>階層が無い場合</h3>
      
      辞書データのように階層構造が存在しないデータでもズーミング検索できるようにするため、
      DragZoomでは仮想的な階層を利用しています。
      例えば
      a, b, c, d, e, f, g
      というフラットなデータがあるときは、
      それぞれに対して
      1, 2, 1, 3, 1, 2, 1
      のような重み(重要度)を与えておきます、
      ユーザが操作する閾値を超えたものだけ表示されますから、
      ユーザのズーミング操作によって
      d, bdf, abcdef
      のように表示が変化することになります。

      <p/>
      DragZoomで
      フラットな英語辞書をブラウズすると初期画面は以下のようになります。

      <blockquote>
        <img src="https://gyazo.com/ca4ee6747874736af660e8d308f2daf7.png" width=400>
      </blockquote>
      
      ここでドラッグ操作でズームレベルを変化させると
      表示は以下のようになります。
      
      <blockquote>
        <img src="https://gyazo.com/094a53375f1b014dca35cad8e9bc1850.png" width=400>
      </blockquote>
      
      さらにズームすると単語の意味が表示されます。
      
      <blockquote>
        <img src="https://gyazo.com/ac99c7f31cc05756daafc51fa63ed4f3.png" width=400>
      </blockquote>
      
      曖昧検索機能を持っているので、適当なキーワードを入力しても
      最も近いエントリが表示されます。
      
      <blockquote>
        <img src="https://gyazo.com/eef271c9690b8b38a40e9abbddfb6767.png" width=400>
      </blockquote>
      
      <h3>その他の応用</h3>
      
      以下は私の手持ちの音楽ファイルで「day」を検索してみたところです。
      このように、ファイルでも辞書でも音楽ファイルでも
      DragZoomで簡単に検索できることがわかります。
      
      <blockquote>
        <img src="https://gyazo.com/af1dbebd48ce955e1811bc91ce088141.png" width=400>
      </blockquote>
            
      <h3>ズーミングシステムの課題</h3>
      
      スクロールバーを使わず
      ズーミングとフィルタリングだけで簡単に大規模データの閲覧や検索ができることは
      大変メリットがあるはずです。 
      多くの大規模データは階層的に構造化されていますから
      DragZoomは広範囲なデータの検索に利用することができるのですが、
      残念ながらこの手法を普及させることには成功していません。

      <p/>
      有用性は十分なのに普及がうまくいかないのは、
      左右ドラッグでズーミングを行なうというインタフェースに慣れるのが難しいことと、
      従来の方法でも特にひどく困ることがないという理由によると思われます。
      DragZoomを使わなくても
      普通のテキスト検索や階層メニューなどで
      階層データをとりあえず眺めることができるのであれば、
      わざわざ新しい手法に乗り換えようとする人は少ないでしょう。

      <p/>
      しかしDragZoomの方法は慣れればかなり便利なのは確かです。
      いろいろなサービスで地味に使えるようにしたうえで、
      今後これをはじめとする
      様々なズーミングインタフェースが普及してほしいものだと願っています。
      
      <p/>
      DragZoomのデモ及びソースコードは...
      で公開しているのでご利用下さい。
      
      <p/>
      

    </div>
  </body>
</html>
