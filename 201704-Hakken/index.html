<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>コロンブス日和 - 発見プログラミング</title>
    <style type="text/css">
      body {
        background-color:#ffffff;
        font-size:12;
        font-family: "Hiragino Kaku Gothic ProN","メイリオ", "sans-serif";
      }
      a { text-decoration: none; }
      li.bold { font-weight: bold; }
      div.body { width:340pt; }
      div.left { float:left; width:10%; font-weight:bold;}
      div.right { width:50%;}
      h1 { background-color:#4d4; padding:8pt;}
      code { background-color:#eee; }
      pre { background-color:#eee; }
    </style>
    <script type="text/javascript">
    //setTimeout("location.reload()",1000*5);
    </script>
  </head>

      <!--
	  解の発見
	    数えあげ関数
	    expand_ruby
              1,2,...,9の並びと加減算で100を作る
	  乱数で何かを発見
	    8-Queenとか
	      交換するだけでもとける
	    進化的プログラミング
	  乱数の性質(分布)の発見
            面白い性質を発見
            正規分布、べき分布
              収入1.2/0.8
	  乱数の片寄りの発見
	    戦争ゲーム
	    正弦
     
	  トーナメント問題
  	  https://scrapbox.io/prog-exercises/%E3%83%88%E3%83%BC%E3%83%8A%E3%83%A1%E3%83%B3%E3%83%88%E5%95%8F%E9%A1%8C

	  発想の発見 アルゴリズムの発見
            三題話発想、 いらすとや発想
	-->

  <body>
    <div class='body'>
      <h1>コロンブス日和 - 発見プログラミング</h1>

      「コロンブスの卵」的なシステムをいろいろ紹介してきたこの連載も
      今回が最終回になりました。

      コロンブスといえば「発見」ということで、最終回の今回は
      プログラミングと発見にまつわる話をしたいと思います。

      <h2>発想と発見</h2>

      研究者でもビジネスマンでも、
      新しくて面白いものを考えなければならない人は
      発明や発見をするために常に頭を使わなければなりませんから
      発想法に関する沢山の本が出版されています。
      たとえば最近出版された
      「発想大全」
      という本には42個もの発想手法が解説されていてとても参考になります。

      <p/>
      発想を得るためには人間が時間をかけて
      やり方を考えたり試行錯誤したり
      努力する必要があります。

      前回紹介した「Scrapbox」は、
      少しでも関連のある情報を柔軟に思い出しやすくすることによって
      発想活動を支援しています。
      
      もし発想活動の一部でも計算機にやらせることができれば
      アイデアを出す効率がアップするかもしれません。

      <h2>プログラミングと発見</h2>

      プログラムを書いて動かすとき、
      どのように動くかに期待があるので、
      おかしな結果が出たときはバグを疑うのが普通かもしれません。

      プログラムが予想通り動いても特に面白いことはありませんが、
      プログラムが意外な挙動をすることによって
      新しい解を発見できることがありますし、
      新しい問題を発見できることすらあるかもしれません。

      <p/>
      失敗から何かを発見したというエピソードは沢山あります。
      もちろんただ失敗すれば良いというものではなく、
      沢山の試行錯誤を行なった結果、
      普通と異なる挙動を見出したことが発見につながったということでしょう。
      
      実はプログラムを動かすことによっても
      様々な発見をすることができます。
      こういう作業を
      発見的プログラミングと呼ぶことにします。

      <p/>
      今回は、
      前回紹介したScrapboxの上に書いたJavaScriptコードを
      ブラウザで実行してみたいと思います。

      Scrapboxには<b>コード記法</b>というものがあり、
      プログラムなどのテキストデータをブロック表示して
      ファイルとして外部からURLでアクセスすることができます。
      これを使えば、
      Scrapbox上に書いたプログラムをブラウザ上で実行することができます。

      CanvasやSVGを利用すると
      JavaScriptでブラウザ上に絵を描くことはできますが、
      初期設定などが必要で面倒なところもあるので、
      描画などを極端に簡単にした
      P5.js
      というシステムを利用することにします。

      <h2>数え上げによる答の発見</h2>

      算数の問題を解くときは
      理屈を考えてから計算するのが普通です。

      たとえば
      「鶴と亀があわせて30匹いて、足の数は全部で100本でした。鶴と亀は何匹いたでしょう?」
      のような
      「つるかめ算」を解く場合、
      「全部が鶴だとすると足の数は60本で、全部が亀だとすると120本になるから...」
      のようにつるかめ算で解くやりかたもありますし、

      <pre>
      t+k=30
      2t+4k=100
      </pre>
      
      のような一次方程式を使うこともできます。

      <p/>
      数学の問題はこのように解析的に解くのが普通ですが、
      以下のような総当たりプログラムを書けば
      数学的知識がなくても力技で答を得ることができます。

      <blockquote>
        <img src="https://gyazo.com/571ff278300cb61655b705e60ebcdb6d.png" width=300><br/>
	Scrapboxでつるかめ算を解く
      </blockquote>
	    
      つるかめ算を解くのにこういうプログラムを書く人は少ないと思いますが、
      このような方法の方が有利な場合もあります。
      もし問題が「足の数が100本以上でした」のようなものであった場合、
      一次方程式で普通に解くことはできませんが、
      上のような方法ならすべての解を網羅できてしまいます。

      つまり、論理的に頑張って解を解けなくても、
      簡単なプログラムを書くことによって解が得られてしまうことになります。

      <p/>
      世の中の問題は「つるかめ算」のように簡単なものばかりだとは限りません。
      複雑な制約や条件があるとき解を求めようとすると、
      力技的なプログラミングで答を発見する方が有効かもしれません。

      <!--
      1,1 1,2 2,1 1,3 2,2 3,1 ....
      のようにすれば総数がわからない場合でも確実にみつけることができる
      -->

      <h2>乱数で答を発見</h2>

      つるかめ算の場合は解の候補をすべて数えあげれば
      答を発見できるはずですが、
      総あたりで発見が難しい場合は
      乱数を使って試行錯誤的に答を捜すこともできます。

      たとえば8-Queen問題を解きたいときは
      再帰的に解を探索するアルゴリズムを使うのが常識的ですが、
      ランダムに行や列を入れ換えることを繰り返すだけでも
      意外と簡単に解を得ることができます。

      <p/>
      まずこのようなデータを用意します。
      
      <pre>
      * . . . . . . .
      . * . . . . . . 
      . . * . . . . .
      . . . * . . . .
      . . . . * . . .
      . . . . . * . .
      . . . . . . * .
      . . . . . . . * 
      </pre>

      ふたつの行をランダムに交換してみると、
      以下のように少しだけ良い結果が得られることがあります。

      <pre>
      * . . . . . . .
      . * . . . . . . 
      . . . * . . . .
      . . * . . . . .
      . . . . * . . .
      . . . . . * . .
      . . . . . . * .
      . . . . . . . * 
      </pre>

      これを何度も繰り返して
      良さげなものを残していくと、
      最終的に以下のような答を得ることができます。

      <pre>
      . . * . . . . .
      * . . . . . . .
      . . . . . . * .
      . . . . * . . .
      . . . . . . . *
      . * . . . . . .
      . . . * . . . .
      . . . . . * . .
      </pre>

      人間は数え上げ操作が苦手ですから、
      8-Queenのような問題に対しては
      試行錯誤的に取り組んで
      答をみつけることが多いですが、
      試行錯誤を計算機に実行させることによって
      解を発見できる場合も多いでしょう。

      <p/>
      遺伝的アルゴリズムや
      Simulated Annealing(焼きなまし法)のような手法は
      乱数を使って試行錯誤的に最適な解をみつける方法で、
      あらゆる組み合わせを試すことができないような
      大規模な問題の解を発見するのに重宝されています。

      <h2>乱数の性質の発見</h2>

      乱数を使って問題を解く場合、
      JavaScriptの
      <code>Math.random()</code>
      のような「一様乱数」関数がよく利用されます。
      Math.random()を呼ぶと
      0から1までのランダムな実数が返ります。
      たとえばrandom()が0.1以下の値を返す確率は1/10です。

      <p/>
      ここまでは普通の話ですが、
      random()で生成した座標に
      を使って点を表示してみると下の図のようになり、
      あんまり一様な感じはしません。

      <blockquote>
	<img src="https://gyazo.com/c921c87b527541e8921fcd62ea3f2e32.png" width=300><br/>
	乱数で生成した座標に点を打つ
      </blockquote>

      <blockquote>
        <img src="https://gyazo.com/f3c1bfc01bde8b4a62a1794c6d065699.png" width=300><br/>
	生成された点
      </blockquote>

      一様な乱数というと下のようなイメージを連想してしまいますが、
      本当の乱数はこうならないことが発見できるのが面白いところです。

      <blockquote>
	<img src="https://gyazo.com/8de4287c0b9ec3333b39ce3078c9f6c3.png" width=300>
      </blockquote>

      乱数はシミュレーションなどでよく利用されるものなので、
      乱数とはどのようなものかについては
      エンジニアであれば誰でもなんとなくイメージを持っていると思いますが、
      乱数を沢山生成して視覚化してみると
      様々な発見があったりします。

      <h3>乱数の足し算</h3>

      いくつかの乱数の平均をとると何が起こるでしょうか?

      ランダムなものをいくら集めてもランダムに決まっているだろうと思うかもしれませんが、
      実は一様な乱数を沢山集めたものは一様乱数にならず、
      正規分布に近付くことが
      <b>中央極限定理</b>
      として知られています。
      ふたつのサイコロをふった場合、
      その数の和が2や12になる確率よりも
      7になる確率の方が大きいだろうということは直感的にわかりますが、
      一様乱数を足した場合も同じだということは
      よく考えないとわからないかもしれません。

      そういう場合、
      何も考えなくても
      プログラムで実行してみれば
      そのような性質はすぐ発見できます。
      
      <blockquote>
        <img src="https://gyazo.com/df389d5c9189c508a173b2f72bd32779.png" width=300><br/>
	乱数を何回か足した結果のヒストグラムを計算
      </blockquote>

      <blockquote>
        <img src="https://gyazo.com/edbeca3c66ed7606e6fcc27dbf9b5bc8.png" width=300><br/>
	計算結果
      </blockquote>

      <h3>乱数の掛け算</h3>

      乱数を沢山足すと正規分布になるわけですが、
      では乱数を沢山かけるとどうなるでしょうか?
      実は
      乱数を何度も掛け算したものは
      以下のような「冪分布」になります。
      下の図では、リニアスケールで青い点を、対数スケールで赤い点を表示しています。
      
      <blockquote>
        <img src="https://gyazo.com/cde4f0ab8f82e92fbcb126b4d926523f.png" width=300><br/>
	乱数の掛け算のプログラム例
      </blockquote>

      <blockquote>
        <img src="https://gyazo.com/8cf7bb1622778ceeeb4a7d8f7d40bfa1.png" width=300><br/>
	実行結果
      </blockquote>
	  
      世の中には「ロングテール」と表現される冪分布が
      沢山ありますが、
      どうやらランダムな事象が掛け算的に繰り返されると
      ロングテール的な現象が発生するようです。

      <p/>
      もっと現実的な場合について考えてみます。
      100万円の資金を持っているとき、
      運によってそれが2割増えたり2割減ったりすることが繰り返されるとどうなるでしょうか。

      これをシミュレートするプログラムを実行すると
      以下のような結果が得られます。
	  
      <blockquote>
        <img src="https://gyazo.com/2f35504da12c290e981b23c02eeb4be7.png" width=300><br/>
	運によって資金が少し増えたりへったりするシミュレーション結果
      </blockquote>
      
      世の中にはちょっと得する機会もちょっと損する機会も沢山ありますが、
      それが積み重なると大きな違いになってしまうことがわかります。

      一方、
      このように財産の分布が大きく変わった場合であっても
      平均をとると最初とほとんど変わらないこともわかります。

      こういう世の中の仕組み(?)が
      簡単なプログラミングで
      発見できてしまうのは興味深いところです。

      <h3>勝負の発見</h3>

      全く五分五分の勝負を繰り返した場合でも
      意外な片寄りを発見することができます。

      <p/>
      トランプに「戦争ゲーム」というのがあります。
      トランプの札をふたりに配り、
      1枚ずつ札を出して勝負するという単純なゲームです。

      たとえばプレーヤ1が「5」を、プレーヤ2が「7」を出したときは
      プレーヤ2の勝ちなので「5」と「7」をゲットします。
      同じ札を出したときは勝負は次に持ち越されます。
      エース(A)は2以外のすべての札に勝ちます。

      <p/>
      このゲームは単純ですし頭を使わないので
      あまり面白いものではありませんが、
      そもそも勝負はつくものなのでしょうか?

      Scrapbox上で
      勝負するプログラムを
      以下のように書くことができます。

      <blockquote>
	<img src="https://gyazo.com/1b49614fcf33d3ca6e00d9a43c409bfa.png" width=300><br/>
	http
	戦争ゲームのプログラム
      </blockquote>

      <blockquote>
	<img src="https://gyazo.com/30644f75a71ce2744d47c9e2be6cfae7.png" width=240><br/>
      	勝負の途中
      </blockquote>
      
      P5.jsの<code>draw()</code>がメインプロセスになって
      勝負の結果を表示しています。
      
      ふたりのプレーヤは
      <code>player()</code>
      というGeneratorで表現されており、
      ふたつのプレーヤプロセスが
      <code>setup()</code>
      で初期化されています。

      <code>player()</code>
      もメインプロセスも
      無限ループになっていますが、
      yieldでメインプロセスと通信することにより
      同期しながら対戦が行なわれます。

      Generator機能を利用すると、
      このようなシミュレータを柔軟に記述することができるので便利です。

      <p/>
      このプログラムを実行すると、
      意外にも割とすぐに決着がついてしまうことがわかります。
      最初の手札は同じですし、
      手の方もランダムにしているにもかかわらず
      あっという間に総取り状態になってしまうということは
      感慨深いものがあります。

      条件が全く同じであっても
      勝負で大勝したり
      大きく儲かったり損したりすることがあることが発見できたことになりますが、
      そういう現象は世の中に沢山みられますし、
      ほんの少しのきっかけで運命が変わってしまうわけですから
      恐いものだと思います。

      <p/>
      このプログラムでは、
      ランダム性を強くするために
      場の札を毎回シャッフルしていますが、
      これをやらない場合は
      何回繰り返しても無限ループになって勝負がつかないケースが多くなります。

      ランダム性が無い方がかえって公平な結果になるということも
      私にとってはもうひとつの発見でした。

      このように、
      単純に見える乱数を使うだけでも
      面白い発見が沢山あります。

      <!--
      逆正弦

      宝クジ

      じゃんけん
      -->

      <h2>おわりに</h2>

      今回紹介したプログラムはすべて
      Scrapbox上に置いてあり、
      クリックするだけでブラウザ上で実行することができます。

      Scrapboxは情報整理に大変便利なシステムですが、
      その上でプログラムを気軽に作成して様々な発見ができることで
      さらに広い応用が考えられると思います。

      <p/>
      18回にわたってコロンブスの卵的な実用的なシステムをいろいろ紹介してきました。
      私はこれらを毎日活用していますが、
      読者の皆様もぜひ試してみていただければと思います。
      
    </div>
  </body>
</html>


