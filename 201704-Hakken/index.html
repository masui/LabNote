<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>コロンブス日和 - 発見プログラミング</title>
    <style type="text/css">
      body {
        background-color:#ffffff;
        font-size:12;
        font-family: "Hiragino Kaku Gothic ProN","メイリオ", "sans-serif";
      }
      a { text-decoration: none; }
      li.bold { font-weight: bold; }
      div.body { width:340pt; }
      div.left { float:left; width:10%; font-weight:bold;}
      div.right { width:50%;}
      h1 { background-color:#4d4; padding:8pt;}
      code { background-color:#eee; }
      pre { background-color:#eee; }
    </style>
    <script type="text/javascript">
    //setTimeout("location.reload()",1000*5);
    </script>
  </head>

      <!--
	  解の発見
	    数えあげ関数
	    expand_ruby
              1,2,...,9の並びと加減算で100を作る
	  乱数で何かを発見
	    8-Queenとか
	      交換するだけでもとける
	    進化的プログラミング
	  乱数の性質(分布)の発見
            面白い性質を発見
            正規分布、べき分布
              収入1.2/0.8
	  乱数の片寄りの発見
	    戦争ゲーム
	    正弦
     
	  トーナメント問題
  	  https://scrapbox.io/prog-exercises/%E3%83%88%E3%83%BC%E3%83%8A%E3%83%A1%E3%83%B3%E3%83%88%E5%95%8F%E9%A1%8C

	  発想の発見 アルゴリズムの発見
            三題話発想、 いらすとや発想
	-->

  <body>
    <div class='body'>
      <h1>コロンブス日和 - 発見プログラミング</h1>

      「コロンブスの卵」的なシステムをいろいろ紹介してきたこの連載も
      今回が最終回になりました。

      コロンブスといえば「発見」なので、最終回の今回は
      プログラミングと発見にまつわる話をしたいと思います。

      <h2>発想と発見</h2>

      エンジニアも作家のように
      新しくて面白いものを考えなければならない人は
      発明や発見をするためにいつも頭を使っていると思います。

      発想法については沢山の本が出版されており、
      発想大全
      という本には30個以上の手法が解説されています。

      KJもマンダラートなかったか

      発想を得るためには人間が時間をかけて努力する必要があります。
      多くのやり方を考えたり試行錯誤したりが必要です。
      
      前回のScrapboxでは
      少しでも関連のある情報を柔軟に思い出すことによって
      発想支援できるようになっています。
      
      発想の一部でも計算機にやらせることができれば
      アイデアの元が自動的に計算されれば素晴らしいでしょう。
      

      <h2>プログラミングと発見</h2>

      プログラムを書いて動かすとき、
      多くの場合は予想に近い結果が出てほしいものであり、
      おかしな結果が出たときはバグがあると思うのが普通かもしれません。


      失敗から発見したというエピソードは沢山あります。
      要するに「何かを沢山試さなければ新しい発見はない」ということでしょう。

      しかし、
      プログラムを書いて動かすことによって
      意外なことが起きることによって
      新しい発見があることもありますし、
      問題の答を発見できることもあります。

      <p/>
      発見的プログラミングと呼びます。

      <p/>
      今回は、
      前回紹介したScrapboxの上に書いたJavaScriptコードを
      ブラウザで実行します。

      Scrapboxにはコード記法というものがあり、
      プログラムのようなテキストデータをブロック表示して
      ファイルとして外部からURLでアクセスすることができます。
      これを使えば、
      Scrapbox上に書いたプログラムをブラウザ上で実行することができるというわけです。

      ここではブラウザ上のJavaScriptで描いたものです。
      CanvasやSVGを利用すると
      JavaScriptでブラウザ上に絵を描くことはできますが、
      これを極端に簡単にした
      P5.js
      というシステムを利用しています

      <blockquote>
	P5.jsによるプログラム
      </blockquote>


      <h2>数え上げによる発見</h2>

      算数の問題を解くときは
      理屈を考えてから計算するのが普通です。

      たとえば
      <!-- t = 10 k = 20 10 * 2 + 4 * 20 -->
      「鶴と亀があわせて30匹いて、足の数は全部で100本でした。鶴と亀は何匹いたでしょう?」
      のような
      「つるかめ算」を解く場合、
      「全部が鶴だとすると足の数は60本で、全部が亀だとすると120本になるから...」
      のようにつるかめ算で解くやりかたもありますし、
      t+k = 30 2t+4k=100
      のような一次方程式を使うこともできます。
      方程式に関する知識があれば普通はこのような式を使って計算するでしょうが、
      プログラムを書けば
      数学的知識がなくても答を得ることができます。

      <pre>
      int tsuru, kame;
      for(tsuru=0;tsuru<=30;tsuru++){
        for(kame=0;kame<=30;kame++){
          if(tsuru + kame == 30 && tsuru * 2 + kame * 4 == 100) break;
	}
      }
      </pre>

      つるかめ算を解くのにこういうプログラムを書く人は少ないと思いますが、
      このように総当り式で計算する方が有利な場合もあります。
      もし問題が「足の数が100本以上でした」のようなものであった場合、
      一次方程式で普通に解くことはできませんが、
      上のような方法ならすべての解を網羅できてしまいます。

      つまり、論理的に頑張って解を解けなくても、
      簡単なプログラムを書くことによって解が得られてしまうことになります。

      <p/>
      世の中の問題は「つるかめ算」のように簡単なものばかりだとは限りません。
      複雑な制約や条件があるとき解を求めようとすると、
      力技的なプログラミングで答を発見する方が有効かもしれません。

      1,1 1,2 2,1 1,3 2,2 3,1 ....

      のようにすれば総数がわからない場合でも確実にみつけることができる

      <h2>乱数で発見</h2>

      つるかめ算の場合は解の候補を数えあげればいつかはみつかりますが、
      総あたりで発見が難しい場合は
      乱数を使って試行錯誤的に発見することができます。

      たとえば8-Queen問題と解きたいときは
      再帰的に解を探索するアルゴリズムを使うのが常識的ですが、
      ランダムに行や列を入れ換えることを繰り返すだけでも
      意外と簡単に解を得ることができます。

      <p/>
      まずこのようなデータを用意します。
      
      <pre>
      * . . . . . . .
      . * . . . . . . 
      . . * . . . . .
      . . . * . . . .
      . . . . * . . .
      . . . . . * . .
      . . . . . . * .
      . . . . . . . * 
      </pre>

      ふたつの行をランダムに交換する操作を行なって
      衝突が少ないものを捜すと、
      以下のような結果が得られます。

      <pre>
      . . * . . . . .
      * . . . . . . .
      . . . . . . * .
      . . . . * . . .
      . . . . . . . *
      . * . . . . . .
      . . . * . . . .
      . . . . . * . .
      </pre>

      人間は数え上げ操作が苦手ですから、
      こういう問題に対しては
      試行錯誤的に取り組んで
      答をみつけることが多いですが、
      試行錯誤を計算機に実行させることによって
      解を発見できる場合も多いでしょう。

      <p/>
      遺伝的アルゴリズムや
      Simulated Annealingのような手法は
      乱数を使って試行錯誤的に最適な解をみつける方法で、
      あらゆる組み合わせを試すことができないような
      大規模な問題の解をみつけるのに重宝されています。

      <p/>
      前の例は
      運が悪いとうまくいかないこともありますが、

      <h2>乱数の性質の発見</h2>

      乱数を使って問題を解く場合、
      JavaScriptの
      <code>Math.random()</code>
      のような「一様乱数」関数がよく利用されます。
      Math.random()を呼ぶと
      0から1までのランダムな実数が返ります。
      たとえばrandom()が0.1以下の値を返す確率は1/10です。

      <p/>
      ここまでは普通の話ですが、
      random()で生成した座標に
      を使って点を表示してみると下の図のようになり、
      あんまり一様な感じはしません。

      <blockquote>
	乱数で生成した座標に点を打つ
      </blockquote>

      <blockquote>
	乱数による図
      </blockquote>

      一様な乱数というと下のようなイメージを連想してしまいますが、
      本当の乱数はこうならないことが発見できるのが面白いと思います。

      <blockquote>
	<img src="https://gyazo.com/8de4287c0b9ec3333b39ce3078c9f6c3.png" width=300>
      </blockquote>

      乱数はシミュレーションなどでよく利用されるものなので、
      乱数とはどのようなものかについては
      エンジニアであれば誰でもなんとなくイメージを持っていると思いますが、
      乱数を沢山生成して視覚化してみると
      様々な発見があったりします。

      <h3>乱数の足し算</h3>

      いくつかの乱数の平均をとると何が起こるでしょうか?

      ランダムなものをいくら集めてもランダムに決まっているだろうと思うかもしれませんが、
      実は一様な乱数を沢山集めたものは一様乱数にならず、
      正規分布に近付くことが
      中央極限定理として
      知られています。
      ふたつのサイコロをふった場合、
      その数の和が2や12になる確率よりも
      7になる確率の方が大きいだろうということは直感的にわかりますが、
      一様乱数を足した場合も同じだということは
      よく考えないとわからないかもしれません。

      そういう場合、
      何も考えなくても
      プログラムで実行してみれば
      そのような性質はすぐ発見できます。
      
      <blockquote>
	乱数の足し算のプログラム例
      </blockquote>

      <blockquote>
	実行結果
      </blockquote>

      <h3>乱数の掛け算</h3>

      乱数を沢山足すと正規分布になるわけですが、
      では乱数を沢山かけるとどうなるでしょうか?
      実は
      乱数を何度も掛け算したものは
      以下のような「冪分布」になります。

      <blockquote>
	乱数の掛け算のプログラム例
      </blockquote>

      <blockquote>
	実行結果
      </blockquote>
	  
      世の中には「ロングテール」と表現される冪分布が
      沢山ありますが、
      どうやらランダムな事象が掛け算的に繰り返されると
      ロングテール的な現象が発生するようです。

      <p/>
      もっと現実的な場合について考えてみます。
      100万円の資金を持っているとき、
      運によってそれが2割増えたり2割減ったりすることが繰り返されるとどうなるでしょうか。
	  
      <blockquote>
	1.2をかける場合と0.8をかける場合
      </blockquote>
      
      世の中にはちょっと得する機会もちょっと損する機会も沢山ありますが、
      それが積み重なると大きな違いになってしまうことがわかります。

      一方、
      このように財産の分布が大きく変わった場合であっても
      平均をとると最初とほとんど変わらないこともわかります。

      こういう世の中の仕組み? が
      はからずも発見されてしまうのは面白いと思います。

      <h3>勝負の発見</h3>

      全く五分五分の勝負を繰り返した場合でも
      面白い片寄りを発見することができます。

      トランプに「戦争ゲーム」というのがあります。
      トランプの札を26枚ずつふたりに配り、
      1枚ずつ札を出して勝負するという単純なゲームです。

      たとえばプレーヤ1が「5」を、プレーヤ2が「7」を出したときは
      プレーヤ2の勝ちなので「5」と「7」をゲットします。
      同じ札を出したときは勝負は次に持ち越されます。
      エース(1)は2以外のすべての札に勝ちます。

      <p/>
      このゲームは単純ですし頭を使わないので
      あまり面白いものではありませんが、
      そもそも勝負はつくものなのでしょうか?

      勝負するプログラムを
      JavaScriptで書いてみましょう。

      <h4>戦争ゲームのプログラム</h4>

      プレーヤの

      逆正弦

      宝クジ

      じゃんけん

      このように、単純に見える乱数を使ってみても
      面白い現象が発見できる
      

      <h2>おわりに</h2>

      今回紹介したプログラムはすべて
      Scrapbox上に置いてあり、
      ブラウザ上で実行することができます。
      
    </div>
  </body>
</html>


